; /*
;
; Copyright 2022 Vulcalien
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <https://www.gnu.org/licenses/>.
;
; */

* = $8000

; SRAM area
.dsb $0400, 0

; ============================================================================ ;

; additional registers in Zero Page
R0 = $00
R1 = $01
R2 = $02
R3 = $03

ARRAY      = $80
ARRAY_SIZE = 15

start:
.(
    ; enable BG 0
    lda     #$01
    sta     $1000

    jsr     initialize_tiles
    jsr     initialize_background

loop:
    jsr     initialize_data
    jsr     wait_key_press
    jsr     bubble_sort
    jsr     wait_key_press

    jsr     initialize_data
    jsr     wait_key_press
    jsr     insertion_sort
    jsr     wait_key_press

    jsr     initialize_data
    jsr     wait_key_press
    jsr     selection_sort
    jsr     wait_key_press

    jmp     loop
.)

set_first_group_tile:
.(
    sta     $5020, x
    sta     $5021, x
    sta     $5022, x
    sta     $5023, x
    sta     $5024, x
    sta     $5025, x
    sta     $5026, x
    sta     $5027, x
    sta     $5028, x
    sta     $5029, x
    sta     $502a, x
    sta     $502b, x
    sta     $502c, x
    sta     $502d, x
    sta     $502e, x
    sta     $502f, x
    sta     $5030, x
    sta     $5031, x
    sta     $5032, x
    sta     $5033, x
    sta     $5034, x
    sta     $5035, x
    sta     $5036, x
    sta     $5037, x
    sta     $5038, x
    sta     $5039, x
    sta     $503a, x
    sta     $503b, x
    sta     $503c, x
    sta     $503d, x
    sta     $503e, x
    sta     $503f, x

    rts
.)

set_second_group_tile:
.(
    sta     $5120, x
    sta     $5121, x
    sta     $5122, x
    sta     $5123, x
    sta     $5124, x
    sta     $5125, x
    sta     $5126, x
    sta     $5127, x
    sta     $5128, x
    sta     $5129, x
    sta     $512a, x
    sta     $512b, x
    sta     $512c, x
    sta     $512d, x
    sta     $512e, x
    sta     $512f, x
    sta     $5130, x
    sta     $5131, x
    sta     $5132, x
    sta     $5133, x
    sta     $5134, x
    sta     $5135, x
    sta     $5136, x
    sta     $5137, x
    sta     $5138, x
    sta     $5139, x
    sta     $513a, x
    sta     $513b, x
    sta     $513c, x
    sta     $513d, x
    sta     $513e, x
    sta     $513f, x

    rts
.)

; set BG tile columns
initialize_tiles:
.(
value  = R0

    lda     #$11
    sta     value               ; value = 0x11

    ldy     #0                  ; Y = counter

loop:
    cpy     #ARRAY_SIZE
    beq     exit

    ; set offset
    tya                         ; A = counter

    asl                         ; A = counter << 1
    asl                         ;         ... << 2
    asl                         ;         ... << 3
    asl                         ;         ... << 4
    asl                         ; A = counter << 5

    tax                         ; X = offset (= counter << 5)

    ; get value
    lda     value               ; A = value

    ; counter:
    ;   [0, 7]  -> first  group
    ;   [7, 15] -> second group
    cpy     #8
    bcs     second_group

    jsr     set_first_group_tile
    jmp     end_second_group

second_group:
    jsr     set_second_group_tile
end_second_group

    ; increment value
    lda     value
    clc
    adc     #$11                ; A = value + 0x11
    sta     value               ; value += 0x11

    iny                         ; counter++
    jmp     loop

exit:
    rts
.)

; Initialize data array in RAM
initialize_data:
.(
    lda     #%00000001
    sta     ARRAY + 14

    lda     #%00000000
    sta     ARRAY + 13

    lda     #%00000100
    sta     ARRAY + 12

    lda     #%00000011
    sta     ARRAY + 11

    lda     #%01100000
    sta     ARRAY + 10

    lda     #%10100000
    sta     ARRAY + 9

    lda     #%11100011
    sta     ARRAY + 8

    lda     #%00011100
    sta     ARRAY + 7

    lda     #%00011111
    sta     ARRAY + 6

    lda     #%00100000
    sta     ARRAY + 5

    lda     #%00000010
    sta     ARRAY + 4

    lda     #%11111100
    sta     ARRAY + 3

    lda     #%11100000
    sta     ARRAY + 2

    lda     #%00010100
    sta     ARRAY + 0

    lda     #%00001100
    sta     ARRAY + 1

    jsr     refresh_save_x_y
    rts
.)

; Initialize background
initialize_background:
.(
    ldx     #0                  ; X = counter
loop:
    cpx     #(ARRAY_SIZE * 2)
    beq     exit

    txa                         ; A = counter
    lsr                         ; A = counter // 2
    clc
    adc     #1                  ; A = counter // 2 + 1

    sta     $4000, x
    sta     $4001, x
    sta     $4020, x
    sta     $4021, x

    sta     $4040, x
    sta     $4041, x
    sta     $4060, x
    sta     $4061, x

    sta     $4080, x
    sta     $4081, x
    sta     $40a0, x
    sta     $40a1, x

    sta     $40c0, x
    sta     $40c1, x
    sta     $40e0, x
    sta     $40e1, x

    sta     $4100, x
    sta     $4101, x
    sta     $4120, x
    sta     $4121, x

    sta     $4140, x
    sta     $4141, x
    sta     $4160, x
    sta     $4161, x

    sta     $4180, x
    sta     $4181, x
    sta     $41a0, x
    sta     $41a1, x

    sta     $41c0, x
    sta     $41c1, x
    sta     $41e0, x
    sta     $41e1, x

    ; counter += 2
    inx
    inx

    jmp     loop
exit:
    rts
.)

; Wait for V-Blank 5 times as a delay
wait_5_vblanks:
.(
    lda     #$a4
    sta     $1001

    lda     #$a3
    sta     $1001

    lda     #$a2
    sta     $1001

    lda     #$a1
    sta     $1001

    lda     #$a0
    sta     $1001

    rts
.)

; Wait for a key to be pressed
wait_key_press:
.(
loop:
    lda     $1010
    cmp     #$ff
    beq     loop

    rts
.)

; Refresh palette
; The values of X and Y registers are preserved
refresh_save_x_y:
.(
    ; push X
    txa
    pha

    ; push Y
    tya
    pha

    jsr     wait_5_vblanks

    ldx     #0                  ; X = counter
loop:
    cpx     #ARRAY_SIZE
    beq     exit

    lda     ARRAY, x            ; A = ARRAY[counter]
    sta     $2001, x            ; palette[counter] = ARRAY[counter]

    inx                         ; counter++
    jmp     loop
exit:

    ; pull Y
    pla
    tay

    ; pull X
    pla
    tax

    rts
.)

; ============================================================================ ;

; === BUBBLE SORT === ;
bubble_sort:
.(
temp = R0

    ldy     #0                  ; Y = outer counter (= i)
outer_loop:
    ; while i != ARRAY_SIZE - 1
    cpy     #(ARRAY_SIZE - 1)
    beq     exit_outer

    ldx     #0                  ; X = inner counter (= j)
inner_loop:
    ; while j != ARRAY_SIZE - 1
    cpx     #(ARRAY_SIZE - 1)
    beq     exit_inner

    lda     ARRAY + 1, x        ; A = ARRAY[j + 1]

    ; if ARRAY[j + 1] < ARRAY[j] then swap
    cmp     ARRAY, x
    bcs     do_not_swap

    ; swap
    sta     temp                ; temp = ARRAY[j + 1]
    lda     ARRAY, x            ; A = ARRAY[j]
    sta     ARRAY + 1, x        ; ARRAY[j + 1] = ARRAY[j]
    lda     temp                ; A = temp
    sta     ARRAY, x            ; ARRAY[j] = temp

    jsr     refresh_save_x_y
do_not_swap:

    inx                         ; inner counter++
    jmp     inner_loop
exit_inner:

    iny                         ; outer counter++
    jmp     outer_loop
exit_outer:

    rts
.)

; ============================================================================ ;

; === INSERTION SORT === ;
insertion_sort:
.(
value = R0

    ldy     #1                  ; Y = outer counter (= i)
outer_loop:
    ; while i != ARRAY_SIZE
    cpy     #ARRAY_SIZE
    beq     exit_outer

    lda     ARRAY, y            ; A = ARRAY[i]
    sta     value               ; value = ARRAY[i]

    ; inner counter = outer counter (A = Y then X = A)
    tya
    tax                         ; X = inner counter (= j)
    dex                         ; j = i - 1
inner_loop:
    ; while j >= 0 ...
    cpx     #0
    bmi     exit_inner

    ; ... && value < ARRAY[j]
    lda     value               ; A = value
    cmp     ARRAY, x
    bcs     exit_inner

    lda     ARRAY, x            ; A = ARRAY[j]
    sta     ARRAY + 1, x        ; ARRAY[j + 1] = ARRAY[j]

    jsr     refresh_save_x_y

    dex                         ; inner counter--
    jmp     inner_loop
exit_inner:

    lda     value               ; A = value
    sta     ARRAY + 1, x        ; ARRAY[j + 1] = value

    jsr     refresh_save_x_y

    iny                         ; outer counter++
    jmp     outer_loop
exit_outer:

    rts
.)

; ============================================================================ ;

; === SELECTION SORT === ;
selection_sort:
.(
min = R0
min_index = R1

    ldy     #0                  ; Y = outer counter (= i)
outer_loop:
    cpy     #(ARRAY_SIZE - 1)
    beq     exit_outer

    ; set ARRAY[i] as minimum
    lda     ARRAY, y            ; A = ARRAY[i]
    sta     min                 ; min = ARRAY[i]

    sty     min_index           ; min_index = i

    ; inner counter = outer counter (A = Y then X = A)
    tya
    tax                         ; X = inner counter (= j)
inner_loop:
    cpx     #ARRAY_SIZE
    beq     exit_inner

    lda     min                 ; A = min

    ; if ARRAY[j] < min then min = ARRAY[j]
    cmp     ARRAY, x
    bcc     do_not_change_min

    ; change min
    lda     ARRAY, x            ; A = ARRAY[j]
    sta     min                 ; min = ARRAY[j]

    stx     min_index           ; min_index = j
do_not_change_min:

    inx                         ; inner counter++
    jmp     inner_loop
exit_inner:

    ; swap ARRAY[i] and min
    lda     ARRAY, y            ; A = ARRAY[i]
    ldx     min_index           ; X = min_index
    sta     ARRAY, x            ; ARRAY[min_index] = ARRAY[i]
    lda     min                 ; A = min
    sta     ARRAY, y            ; ARRAY[i] = min

    jsr     refresh_save_x_y

    iny                         ; outer counter++
    jmp     outer_loop
exit_outer:

    rts
.)

; ============================================================================ ;

; add padding bytes to reach the vectors
.(
start_of_padding:
    * = $fffa
    .dsb (* - start_of_padding), 0
    * = $fffa
.)

; --- VECTORS ---
    .word   $0000                       ; nmi
    .word   start                       ; reset
    .word   $0000                       ; irq
